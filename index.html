<!DOCTYPE html>
<!-- saved from url=(0039)http://www.w3.org/TR/css-will-change-1/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>CSS Will Change Module Level 1</title>
  <link href="./assets/default.css" rel="stylesheet" type="text/css">
  <link href="http://www.w3.org/StyleSheets/TR/W3C-WD" rel="stylesheet" type="text/css">
</head>
<body class="h-entry">
<div class="head">
  <p><a href="http://www.w3.org/">
    <img alt="W3C" height="48" src="https://www.w3.org/Icons/w3c_home" width="72">
</a>
</p>
  <h1 class="p-name no-ref" id="title">CSS Will Change 模型级别 1</h1>
  <h2 class="no-num no-toc no-ref heading settled heading" id="subtitle"><span class="content">W3C 首次公布工作草案,
    <span class="dt-updated"><span class="value-title" title="20140429">29 April 2014</span></span></span></h2>
  <div data-fill-with="spec-metadata"><dl><dt>此版本:</dt><dd><a class="u-url" href="http://www.w3.org/TR/2014/WD-css-will-change-1-20140429/">http://www.w3.org/TR/2014/WD-css-will-change-1-20140429/</a></dd><dt>上一版本:</dt><dd><a href="http://www.w3.org/TR/css-will-change-1/">http://www.w3.org/TR/css-will-change-1/</a></dd><dt>编辑的草案:</dt><dd><a href="http://dev.w3.org/csswg/css-will-change/">http://dev.w3.org/csswg/css-will-change/</a>
  </dd><dt>信息反馈:</dt>
        <dd><a href="mailto:www-style@w3.org?subject=%5Bcss-will-change%5D%20feedback">www-style@w3.org</a>
            with subject line
            “<kbd>[css-will-change] <var>… message topic …</var></kbd>”(<a href="http://lists.w3.org/Archives/Public/www-style/" rel="discussion">archives</a>)</dd><dt>测试集:</dt><dd>None Yet</dd><dt>编辑者:
</dt><dd class="p-author h-card vcard"><a class="p-name fn u-url url" href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (<span class="p-org org">Google Inc.</span>)</dd></dl></div>
  <div data-fill-with="warning"></div>
  <p class="copyright" data-fill-with="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2014 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
  </p>
  <hr title="Separator for header">
</div>

<h2 class="no-num no-toc no-ref heading settled heading" id="abstract"><span class="content">文摘</span></h2>
<p class="p-summary" data-fill-with="abstract">本文档定义CSS的属性----<a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a> ,这个属性允许一个开发者(CSS作者)提前告知用户代理一个元素可能会做出的改变.  允许用户代理提前优化需要改变的元素, 在动画真正开始之前,为动画提前完成一些的重度开销.
在屏幕,在纸,在演讲等等中,<a href="http://www.w3.org/TR/CSS/">CSS</a>是一门语言用来描述结构化的渲染文档
(例如HTML和XML)
</p>

<h2 class="no-num no-toc no-ref heading settled heading" id="status"><span class="content">本文档的状态</span></h2>
<div data-fill-with="status"><p><em>本区域描述了本文档公布时文档的状态. 其它文档可能替代本篇文档.W3C文档当前公开的和上一版的技术性报告
   可以在<a href="http://www.w3.org/TR/">W3C技术性报告
   索引 http://www.w3.org/TR/.</a>中找到</em>

 </p><p>本文档是<b>首次公布的工作草案</b>.

 </p><p>首次公开工作组草案并不意外着被WC3成员认可. 这是一份草案文本并且它随时可能被其他文档在任何时候更新, 替代或者废除.
   在其他工作进程中引用这篇文档是不合适的.

 </p><p>(<a href="http://lists.w3.org/Archives/Public/www-style/">档案室</a>)公开的邮件组
    <a href="mailto:www-style@w3.org">www-style@w3.org</a> (查看
   <a href="http://www.w3.org/Mail/Request">说明</a>) 申请讨论此规范. 当发送一封邮件, 请在邮件主题上写上“css-will-change” , 最好像这样:
   “[css-will-change] <em>…summary of comment…</em>”

 </p><p>本文档是由<a href="http://www.w3.org/Style/CSS/members">CSS工作组</a>产出 (<a href="http://www.w3.org/Style/">Style Activity(样式活动)</a>的一部分).

 </p><p>本文档的产出是在<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February
   2004 W3C Patent Policy</a>之下通过小组产出. W3C维护了一个<a href="http://www.w3.org/2004/01/pp-impl/32061/status" rel="disclosure">任何公开专利的列表</a>和小组的产出做出了关联; 那个页面也包括了
   专利的使用说明. 个体所拥有的专利知识,个体认为包含在<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
   Claim(s)</a>中公开信息必须和<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
   6 of the W3C Patent Policy</a>具有一致性.</p>
</div>
<div data-fill-with="at-risk"></div>

<h2 class="no-num no-toc no-ref heading settled heading" id="contents"><span class="content">内容目录</span></h2>
<div data-fill-with="table-of-contents"><ul class="toc">
	<li><a href="#intro"><span class="secno">1</span> 介绍</a>
	</li><li><a href="#will-change"><span class="secno">2</span> 说明在未来的行为: <span class="property" data-link-type="propdesc" title="will-change">will-change</span> 属性</a>
	</li><li><a href="#conformance"><span class="secno"></span> 一致性</a>
		<ul class="toc">
		<li><a href="#conventions"><span class="secno"></span> 文档规定</a>
		</li><li><a href="#conformance-classes"><span class="secno"></span> 一致性类别</a>
		</li><li><a href="#partial"><span class="secno"></span>部分实现方法</a>
		</li><li><a href="#experimental"><span class="secno"></span>实验性方法</a>
		</li><li><a href="#testing"><span class="secno"></span>非实验性方法</a></li></ul>
	</li><li><a href="#references"><span class="secno"></span> 参考资料</a>
		<ul class="toc">
		<li><a href="#normative"><span class="secno"></span>规范系参考</a>
		</li><li><a href="#informative"><span class="secno"></span>信息系参考</a></li></ul>
	</li><li><a href="#index"><span class="secno"></span> 索引</a>
	</li><li><a href="#property-index"><span class="secno"></span> 属性索引</a></li></ul></div>




<h2 class="heading settled heading" data-level="1" id="intro"><span class="secno">1 </span><span class="content">
介绍</span><a class="self-link" href="#intro"></a></h2>

<p>	现代CSS渲染经过大量复杂的逻辑优化以保证页面渲染的快速和有效.
	遗憾地, 使用这样的逻辑优化通常是需要花费非常重度的启用开销,
	这样的开销能够对一个页面的响应是有负面的影响的.

	</p><div class="example">
		举个例子说明, 当我们使用CSS 3D Transforms在屏幕上去移动一个元素的时候,
		这个元素和它的内容可能去提升它们的“layer(阶层)”,
		这样可以使得它们独立于页面其他部分去渲染并且可以生成的较晚.
		这样独立的去渲染内容以便于页面剩余的内容不需要去渲染
		如果这个这个元素仅仅是transform需要在帧数和帧数之间改变,
		这样独立的渲染通常对页面速度的提升有很大的好处.

<p>		当然, 设置这个元素到一个新的阶层上是一个相对开销比较大的操作,
		这个操作可以延迟一个<a class="property" data-link-type="propdesc" href="http://www.w3.org/TR/css3-transforms/#propdef-transform" title="transform">transform</a>动画的开始通过一个明显的瞬间.
	</p></div>

<p>在此规范中的<a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a> 属性定义允许开发者(CSS作者)去提前声明一些可能在未来会发生改变的属性,
	在这些属性需要(改变)之前,便于用户代理在一段时间内可以设置一些适当的逻辑优化.
	这种方式, 当改变真的发生时,
	页面的更新就非常爽快了.

</p><h2 class="heading settled heading" data-level="2" id="will-change"><span class="secno">2 </span><span class="content">
说明在未来的行为: <a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>属性</span><a class="self-link" href="#will-change"></a></h2>

<table class="definition propdef"><tbody><tr><th>属性名:</th><td><dfn class="css-code" data-dfn-type="property" data-export="" id="propdef-will-change">will-change<a class="self-link" href="#propdef-will-change"></a></dfn></td></tr><tr><th>属性值:</th><td class="prod">auto | <a class="production css-code" data-link-type="type" href="#typedef-animateable-feature" title="&lt;animateable-feature&gt;">&lt;animateable-feature&gt;</a>#</td></tr><tr><th>初始值:</th><td>auto</td></tr><tr><th>应用于:</th><td>all elements</td></tr><tr><th>继承性:</th><td>no</td></tr><tr><th>媒体:</th><td>all</td></tr><tr><th>计算值:</th><td>specified value</td></tr><tr><th>百分比:</th><td>n/a</td></tr></tbody></table>
<pre class="prod"><dfn class="css-code" data-dfn-type="type" data-export="" id="typedef-animateable-feature">&lt;animateable-feature&gt;<a class="self-link" href="#typedef-animateable-feature"></a></dfn> = scroll-position | contents | <a class="production css-code" data-link-type="type" href="http://www.w3.org/TR/css3-values/#identifier-value" title="&lt;custom-ident&gt;">&lt;custom-ident&gt;</a></pre>
<p><a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a> 属性 为用户代理提供了一个渲染的线索,
	开始于开发者(CSS作者)在这个元素期望去做的多种改变.
	这个属性允许用户代理去提前完成一些必要的逻辑优化使得渲染这些改变时更加流畅,
	避免了当开发者(CSS作者) 改变属性或者动画开始时的“jank”特性.

</p><p>属性值拥有以下的值:

	</p><dl data-dfn-for="will-change" data-dfn-type="value">
		<dt><dfn class="css-code" data-dfn-for="will-change" data-dfn-type="value" data-export="" id="valuedef-auto">auto<a class="self-link" href="#valuedef-auto"></a></dfn>
		</dt><dd>
<p>			表示没有明确的意图;
			无论是启发式和最优化，用户代理应该应用都和正常情况相同.

		</p></dd><dt><dfn class="css-code" data-dfn-for="will-change" data-dfn-type="value" data-export="" id="valuedef-scroll-position">scroll-position<a class="self-link" href="#valuedef-scroll-position"></a></dfn>
		</dt><dd>
<p>			表示开发者(CSS作者)期望去在接下来去改变或者有动画应用元素的滚动位置.

			</p><p class="example">
				举个例子来说, 在一个可滚动的元素上浏览器通常仅仅会渲染"scroll window"的内容,
				并且有一些内容会超过这个窗口,
				在使得滚动看上去更加的好之前，通过跳过渲染去平衡内存和节约时间 .
				一个浏览器可能会取这个值作为一个信号去扩大内容在滚动窗口中的范围当滚动窗口被渲染,
				以至于长(快速)滚动能够被执行的更流畅.

		</p></dd><dt><dfn class="css-code" data-dfn-for="will-change" data-dfn-type="value" data-export="" id="valuedef-contents">contents<a class="self-link" href="#valuedef-contents"></a></dfn>
		</dt><dd>
<p>			表示开发者(CSS作者)期望去在接下来去改变或者有动画应用元素的内容

			</p><p class="example">
				举个例子来说, 浏览器通常会 “cache(缓存)” 一段时间内渲染的元素,
				因为通常大多数这些元素不会频繁改变,
				或者也仅仅只是改变它们的位置.
				当然, 如果一个元素 *会* 频繁改变它的内容,
				产生和维持这样的缓存是非常浪费时间的.
        一个浏览器可能会取这个值作为一个信号去主动减少在这个元素上的缓存
				或者避免缓存所有和紧紧去重复渲染这个元素经常被改变的内容.

		</p></dd><dt><dfn class="css-code" data-dfn-for="will-change" data-dfn-type="value" data-export="" id="valuedef-custom-ident"><a class="production css-code" data-link-type="type" href="http://www.w3.org/TR/css3-values/#identifier-value" title="&lt;custom-ident&gt;">&lt;custom-ident&gt;</a><a class="self-link" href="#valuedef-custom-ident"></a></dfn>
		</dt><dd>
<p>			表示开发者(CSS作者)期望去在接下来去改变或者有动画应用指定的元素的属性.

</p><p>			<a class="production css-code" data-link-type="type" href="http://www.w3.org/TR/css3-values/#identifier-value" title="&lt;custom-ident&gt;">&lt;custom-ident&gt;</a> 产生是用来排除这里的关键字 <span class="css" data-link-type="maybe" title="will-change">will-change</span>, <span class="css" data-link-type="maybe" title="none">none</span>, <span class="css" data-link-type="maybe" title="all">all</span>, <a class="css" data-link-type="maybe" href="#valuedef-auto" title="auto">auto</a>, <a class="css" data-link-type="maybe" href="#valuedef-scroll-position" title="scroll-position">scroll-position</a>, and <a class="css" data-link-type="maybe" href="#valuedef-contents" title="contents">contents</a>,
			从<a class="production css-code" data-link-type="type" href="http://www.w3.org/TR/css3-values/#identifier-value" title="&lt;custom-ident&gt;">&lt;custom-ident&gt;</a>之外增加一些通用的关键字 .

</p><p class="note">			注释: 注意所有的属性都没有受到影响在规定时,
			针对所有属性的改变, 用户代理不能够完成任何已经明确规定的逻辑优化的改变.
			这仍然是 <em>安全</em>的去规定它们, 尽管;
			这将仅仅只是简单的没有影响.

</p><p>			如果一个属性无最初的值,在这个元素上这个属性将创建一个堆栈的内容,
			明确规定在<a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>的属性必须在这个元素上创建一个堆栈的内容.

</p><p>			如果一个属性无最初的值, 这个属性将造成这个元素产生一个包含区块的固定定位的元素,
			明确规定在 <a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>的属性必须造成这个元素产生一个包含区块的固定定位的元素

</p><p>			如果一个属性无最初的值, 这个属性将造成在这个元素上渲染行为的不同
			(就像对文本使用了一个与众不同反混淆的策略),
			用户代理应该使用轮流渲染当这个属性在 <a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>被明确规定时,
		去避免渲染行为的突然不同当这个属性终于被改变时.

			</p><p class="example">
				举个例子来说, 浏览器通常会操作元素的<a class="property" data-link-type="propdesc" href="http://www.w3.org/TR/css3-transforms/#propdef-transform" title="transform">transform</a>去设置一个来自于正常元素中没有初始值,非常独特的元素,
				或者可能渲染它们通过它们本身的“GPU layer(GPU层)”
				或者引用其他的途径使得转换种类变得能够更加简单的去变快使得<a class="property" data-link-type="propdesc" href="http://www.w3.org/TR/css3-transforms/#propdef-transform" title="transform">transform</a>能够产生.
				一个浏览器可能会取<a class="property" data-link-type="propdesc" href="http://www.w3.org/TR/css3-transforms/#propdef-transform" title="transform">transform</a>的值作为一个信号
				这个信号应该立刻继续和立刻提高这个元素本身的层,
				在这个元素进行转化之前,
				在旧和新的层渲染时候去避免任何延迟调用.
	</p></dd></dl>


	<div class="example">
		举个例子来说, 设置<a class="property" data-link-type="propdesc" href="http://www.w3.org/TR/css3-color/#opacity" title="opacity">opacity</a>任何一个超过<span class="css" data-link-type="maybe" title="1">1</span>的其它值我在这个元素上产生一个堆栈的内容.
		因此, 设置 <a class="css" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change: opacity</a>也会产生一个堆栈内容,
		即使 <a class="property" data-link-type="propdesc" href="http://www.w3.org/TR/css3-color/#opacity" title="opacity">opacity</a><em>目前</em> 仍然等价于 <span class="css" data-link-type="maybe" title="1">1</span>.
	</div>

<p>明确规定<a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>属性对元素没有<em>直接</em>的影响,
	超出堆栈的内容创建和内容区块和以上规定一样.
	这个属性仅仅是一个用户代理的渲染线索,
	在改变真正发生之前,允许用户代理对确定的改变的类型设置潜在开销巨大的优化操作

	</p><div class="note">
		不同的浏览器能够用不同的方式使用<a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>信息,
		并且甚至对于单独的浏览器可以在不同的时间用不同的方式去使用这个信息.
		举个例子来说, 一个浏览器可以提高元素自己的“GPU layer(GPU层)”
		当它们有<a class="css" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change: transform</a>规定时
		可能避免去做当有<em>大量的</em>元素去声明,
		去避免耗尽GPU的内存.

<p>		开发者(CSS作业)应该避免去滥用这个属性,
		并且不应该将这个属性应用这样的元素除非元素本身已知(或者有个预期行为)和这个元素明确将会很快发生改变
	  举个例子, 在一个静态CSS表里将<a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>应用在一个元素上
		通常可能是错误的;
		大多数情况,
		<a class="property" data-link-type="propdesc" href="#propdef-will-change" title="will-change">will-change</a>的应用应该通过script,
		动画开始或者属性开始改变之前有一段非常短的空白,
		并且应该马上将这个属性重置为<a class="css" data-link-type="maybe" href="#valuedef-auto" title="auto">auto</a>这个初始值
		当这个元素停止改变时
	</p></div>

<h2 class="no-ref no-num heading settled heading" id="conformance"><span class="content">
 一致性</span><a class="self-link" href="#conformance"></a></h2>

<h3 class="no-ref heading settled heading" id="conventions"><span class="content">
文档规定</span><a class="self-link" href="#conventions"></a></h3>

    <p>一致性的需求表达结合了
    描述性声明和RFC 2119术语. 关键词 "MUST",
    "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
    "RECOMMENDED", "MAY", 和 "OPTIONAL" 在这篇文档的规范性部分将会被解释为就像RFC 2119描述中的一样.
    当然, 为了可读性, 在这篇规范中,这些关键词都不会呈现为大写字母.

  </p><p>本规范的所有文本都是标准的除了一些非常明显的区域被标记为 非标准的, 举例, 和 注释. <a data-biblio-type="normative" data-link-type="biblio" href="#rfc2119" title="rfc2119">[RFC2119]</a></p>

    <p>本规范的例子都是用关键字"for example"作为引导
    或者标准的文本使用<code>class="example"</code>建立出来的部分,
    like this:

    </p><div class="example">
        <p>这是一个关于提供信息的例子.</p>
    </div>

    <p>信息的注释使用"Note"关键字作为起始标志并且准标的文本使用<code>class="note"</code>建立出来的部分, 就像这样:

    </p><p class="note">注释, 这是一个提供信息的注释.</p>

<h3 class="no-ref heading settled heading" id="conformance-classes"><span class="content">
一致性类</span><a class="self-link" href="#conformance-classes"></a></h3>

    <p>这篇规范的一致性的定义是通过三种一致性类来定义的:
    </p><dl>
        <dt>样式表
        </dt><dd>A <a href="http://www.w3.org/TR/CSS21/conform.html#style-sheet">CSS样式表</a>.
        </dd><dt>渲染
        </dt><dd>一个 <a href="http://www.w3.org/TR/CSS21/conform.html#user-agent">用户代理</a>
            用来解释样式表的语法并且渲染文档时使用.
        </dd><dt>编辑工具
        </dt><dd>一个<a href="http://www.w3.org/TR/CSS21/conform.html#user-agent">用户代理</a>
            用来编写样式表.
    </dd></dl>

    <p>样式表规划于本规范
    如果样式表所有的语句使用的语法在这个模块中去定义
    按照通用CSS语法都是有效的并且每一个特点的单独的语法在这个模型中被定义.

  </p><p>渲染规划于本规范
    如果, 为了增加解释样式表所以通过适合的规范被定义了, 它支持所有通过本规范所被定义的特点,通过正确语法解析
    并且按照语法渲染这篇文档. 当然, 无能的用户代理能够正确渲染出文档由于设备的局限不能使用户代理按照规划去做.
    (举个例子来说, 用户代理在黑白显示器中不需要去渲染颜色.)

  </p><p>编辑工具规划于本规范
    如果用编辑工具编写样式表在语句构成上都能够正确的匹配通用CSS语法和每一个在这个模型里独特的语法,
    其他所有遇见的一致性的需求的样式表都在这个模型中被描述出来

</p><h3 class="no-ref heading settled heading" id="partial"><span class="content">
部分实现的方法</span><a class="self-link" href="#partial"></a></h3>

    <p>由于开发者(CSS作者)能够利用向前兼容的解析规则去指定回调的值, CSS的渲染<strong>必须</strong>
    被视为都是有效的(同时<a href="http://www.w3.org/TR/CSS21/conform.html#ignore">适当的忽略</a>)在任意向前规则, 属性, 属性值, 关键字,
    和其它一些语法构建对于它们有可能还不够等级去支持的. 尤其是, 用户代理<strong>一定不能</strong>选择
    无视掉不支持的组成部分的值并且名义上支持的值是一个属性的
    多个值中的一个值的声明: 如果任何一个值被视为作废
    (被视为一个不支持的值), 整个声明都需要被CSS无视掉.</p>

<h3 class="no-ref heading settled heading" id="experimental"><span class="content">
实验性的方法</span><a class="self-link" href="#experimental"></a></h3>

    <p>为了避免和未来的CSS特点发生冲突, CSS2.1规范
    预定保留<a href="http://www.w3.org/TR/CSS21/syndata.html#vendor-keywords">前缀语法</a>
    对于属性和实验性扩展在CSS中.

  </p><p>较早的规范的获取在W3C process中的候选推荐时期区域, 所有实现的CSS方法都被认为是实验性的.
    CSS工作组推荐实现的方法
    使用产商前缀语法对于CSS特征, 包括在
    W3C工作草案中. 这是为了未来在草案中变更时避免不兼容性.
    </p>

<h3 class="no-ref heading settled heading" id="testing"><span class="content">
非实验性的方法</span><a class="self-link" href="#testing"></a></h3>

    <p>一旦一个规范能够在候选推荐时期区域获取到,
    非实验性的方法就是可能, 并且方法应该
    发布非前缀的方法,在任何CR-level特点 ,根据本规范它们能够正确被演示出来的方法.

  </p><p>为了发布和维护互操作性CSS的方法, CSS工作组要求非实验性的
    CSS渲染提交一个方法报告(并且, 如果有必要, 针对这篇报告附上测试用例)到W3C在
    发布一个在任何CSS特点的非前缀方法之前. 测试案例提交给W3C并且通过CSS工作组作为主题去检查和修正.

  </p><p>更多关于提交测试案例的信息和方法报告
    可以通过CSS工作组的网站被找到, 地址是
    <a href="http://www.w3.org/Style/CSS/Test/">http://www.w3.org/Style/CSS/Test/</a>.
    如果有任何疑问请发邮件到
    <a href="http://lists.w3.org/Archives/Public/public-css-testsuite">public-css-testsuite@w3.org</a>
    .

</p><h2 class="no-num no-ref heading settled heading" id="references"><span class="content">
参考</span><a class="self-link" href="#references"></a></h2>

<h3 class="no-num no-ref heading settled heading" id="normative"><span class="content">
参考的标准</span><a class="self-link" href="#normative"></a></h3>
<div data-fill-with="normative-references"><dl><dt id="rfc2119" title="RFC2119"><a class="self-link" href="#rfc2119"></a>[RFC2119]</dt><dd>S. Bradner. <a href="http://www.ietf.org/rfc/rfc2119.txt">在RFCs中使用关键字去指示文档的级别</a>. URL: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a></dd></dl></div>

<h3 class="no-num no-ref heading settled heading" id="informative"><span class="content">
参考的信息</span><a class="self-link" href="#informative"></a></h3>
<div data-fill-with="informative-references"><dl></dl></div>

<h2 class="no-num no-ref heading settled heading" id="index"><span class="content">
索引</span><a class="self-link" href="#index"></a></h2>
<div data-fill-with="index"><ul class="indexlist">
<li>&lt;animateable-feature&gt;, <a href="#typedef-animateable-feature" title="section 2">2</a>
</li><li>auto, <a href="#valuedef-auto" title="section 2">2</a>
</li><li>contents, <a href="#valuedef-contents" title="section 2">2</a>
</li><li>&lt;custom-ident&gt;, <a href="#valuedef-custom-ident" title="section 2">2</a>
</li><li>scroll-position, <a href="#valuedef-scroll-position" title="section 2">2</a>
</li><li>will-change, <a href="#propdef-will-change" title="section 2">2</a>
</li></ul></div>

<h2 class="no-num no-ref heading settled heading" id="property-index"><span class="content">
属性的索引</span><a class="self-link" href="#property-index"></a></h2>
<div data-fill-with="property-index"><table class="proptable data"><thead><tr><th scope="col">属性名</th><th scope="col">属性值</th><th scope="col">初始值</th><th scope="col">应用于</th><th scope="col">Inh.</th><th scope="col">%ages</th><th scope="col">媒体</th><th scope="col">生成值</th></tr></thead><tbody>
<tr><th scope="row"><a class="css-code" data-link-type="property" href="#propdef-will-change" title="will-change">will-change</a></th><td>auto | &lt;animateable-feature&gt;#</td><td>auto</td><td>all elements</td><td>no</td><td>n/a</td><td>all</td><td>specified value</td></tr></tbody></table></div>


</body></html>
